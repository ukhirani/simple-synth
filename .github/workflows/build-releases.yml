name: Build Multi-Platform Releases

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build-windows:
    runs-on: windows-latest
    
    steps:
    - uses: actions/checkout@v4
      with:
        submodules: recursive
    
    - name: Setup MSVC
      uses: microsoft/setup-msbuild@v2
    
    - name: Create signalsmith-basics stubs
      run: |
        New-Item -ItemType Directory -Force -Path "basics/include/signalsmith-basics"
        New-Item -ItemType Directory -Force -Path "basics/include/stfx"
        
        @'
        #pragma once
        #include <cmath>
        namespace signalsmith { namespace basics {
          class ReverbFloat {
          public:
            float wet = 0.0f; float dry = 1.0f; float roomMs = 100.0f;
            float lowCutHz = 20.0f; float highCutHz = 20000.0f; float rt20 = 2.0f;
            ReverbFloat() {}
            void process(float** channels, int numSamples) {
              for (int i = 0; i < numSamples; i++) {
                for (int ch = 0; ch < 2; ch++) {
                  channels[ch][i] = channels[ch][i] * (dry + wet * 0.8f);
                }
              }
            }
            void configure(float sampleRate, float roomSize = 0.5f, float damping = 0.5f) {}
            void setRoomSize(float size) {} void setDamping(float damping) {} void setMix(float mix) {}
          };
        }}
        '@ | Out-File -FilePath "basics/include/signalsmith-basics/reverb.h" -Encoding utf8
        
        @'
        #pragma once
        #include <cmath>
        namespace signalsmith { namespace basics {
          class CrunchFloat {
          public:
            float fuzz = 0.0f; float drive = 1.0f; float toneHz = 5000.0f;
            float cutHz = 20000.0f; float outGain = 1.0f;
            CrunchFloat() {}
            void process(float** channels, int numSamples) {
              for (int i = 0; i < numSamples; i++) {
                for (int ch = 0; ch < 2; ch++) {
                  float sample = channels[ch][i] * drive;
                  channels[ch][i] = std::tanh(sample) * outGain * (1.0f + fuzz);
                }
              }
            }
            void configure(float sampleRate, int samplesPerBlock = 512) {}
            void setGain(float gain) { outGain = gain; } void setMix(float mix) {}
          };
        }}
        '@ | Out-File -FilePath "basics/include/signalsmith-basics/crunch.h" -Encoding utf8
        
        @'
        #pragma once
        #include <cmath>
        namespace signalsmith { namespace basics {
          class ChorusFloat {
          public:
            float mix = 0.0f; float depthMs = 5.0f; float detune = 0.0f; float stereo = 0.0f;
            ChorusFloat() : phase(0.0f) {}
            void process(float** channels, int numSamples) {
              for (int i = 0; i < numSamples; i++) {
                float lfo = std::sin(phase) * depthMs * 0.01f;
                for (int ch = 0; ch < 2; ch++) {
                  channels[ch][i] = channels[ch][i] * (1.0f + lfo * mix);
                }
                phase += 0.001f;
                if (phase > 6.28f) phase -= 6.28f;
              }
            }
            void configure(float sampleRate, int samplesPerBlock = 512) {}
            void setRate(float rate) {} void setDepth(float depth) { depthMs = depth; }
            void setMix(float mixVal) { mix = mixVal; }
          private:
            float phase;
          };
        }}
        '@ | Out-File -FilePath "basics/include/signalsmith-basics/chorus.h" -Encoding utf8
        
        @'
        #pragma once
        #include <algorithm>
        namespace signalsmith { namespace basics {
          class LimiterFloat {
          public:
            float inputGain = 1.0f; float outputLimit = 1.0f; float attackMs = 1.0f;
            float holdMs = 0.0f; float releaseMs = 10.0f;
            LimiterFloat() {}
            void process(float** channels, int numSamples) {
              for (int i = 0; i < numSamples; i++) {
                for (int ch = 0; ch < 2; ch++) {
                  float sample = channels[ch][i] * inputGain;
                  channels[ch][i] = std::max(-outputLimit, std::min(outputLimit, sample));
                }
              }
            }
            void configure(float sampleRate, int samplesPerBlock = 512) {}
            void setThreshold(float threshold) { outputLimit = threshold; }
            void setRelease(float release) { releaseMs = release; }
          };
        }}
        '@ | Out-File -FilePath "basics/include/signalsmith-basics/limiter.h" -Encoding utf8
        
        @'
        #pragma once
        #include <cmath>
        namespace stfx { namespace units {
          inline float dbToGain(float db) { return std::pow(10.0f, db / 20.0f); }
        }}
        '@ | Out-File -FilePath "basics/include/stfx/units.h" -Encoding utf8
        
    - name: Install JUCE
      run: |
        git clone --depth 1 --branch 8.0.8 https://github.com/juce-framework/JUCE.git
        if (!(Test-Path "JUCE")) {
          git clone --depth 1 --branch 7.0.12 https://github.com/juce-framework/JUCE.git
        }
    
    - name: Configure CMake
      run: |
        cmake -B build -G "Visual Studio 17 2022" -A x64 `
          -DJUCE_BUILD_EXTRAS=OFF -DJUCE_BUILD_EXAMPLES=OFF `
          -DCMAKE_BUILD_TYPE=Release
    
    - name: Build
      run: |
        cmake --build build --config Release --target SimpleSynth_Standalone
    
    - name: Package Windows Executable
      run: |
        mkdir -p artifacts
        $exePath = Get-ChildItem -Path "build" -Recurse -Include "*.exe" | Where-Object { $_.Name -like "*SimpleSynth*" } | Select-Object -First 1
        if ($exePath) {
          Copy-Item $exePath.FullName "artifacts/SimpleSynth.exe"
          Write-Host "Found executable: $($exePath.FullName)"
        } else {
          Write-Host "Searching for any executables..."
          Get-ChildItem -Path "build" -Recurse -Include "*.exe" | ForEach-Object { Write-Host $_.FullName }
          Write-Error "Standalone executable not found"
          exit 1
        }
    
    - name: Upload Windows Artifact
      uses: actions/upload-artifact@v4
      with:
        name: SimpleSynth-Windows
        path: artifacts/SimpleSynth.exe

  build-linux:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
      with:
        submodules: recursive
    
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential cmake pkg-config \
          libgtk-3-dev libwebkit2gtk-4.1-dev libcurl4-openssl-dev \
          libasound2-dev libjack-jackd2-dev ladspa-sdk \
          libfreetype6-dev libx11-dev libxcomposite-dev libxcursor-dev \
          libxext-dev libxinerama-dev libxrandr-dev libxrender-dev \
          libgl1-mesa-dev libglu1-mesa-dev python3-pip
        pip3 install Pillow || echo "Pillow install failed, using fallback"
    
    - name: Create signalsmith-basics stubs
      run: |
        mkdir -p basics/include/signalsmith-basics
        
        cat > basics/include/signalsmith-basics/reverb.h << 'EOF'
        #pragma once
        #include <cmath>
        namespace signalsmith { namespace basics {
          class ReverbFloat {
          public:
            ReverbFloat() {}
            void process(float* input, float* output, int samples) {
              for (int i = 0; i < samples; i++) output[i] = input[i] * 0.8f;
            }
            void configure(float sampleRate, float roomSize = 0.5f, float damping = 0.5f) {}
            void setRoomSize(float size) {}
            void setDamping(float damping) {}
            void setMix(float mix) {}
          };
        }}
        EOF
        
        cat > basics/include/signalsmith-basics/crunch.h << 'EOF'
        #pragma once
        #include <cmath>
        namespace signalsmith { namespace basics {
          class CrunchFloat {
          public:
            CrunchFloat() {}
            void process(float* input, float* output, int samples) {
              for (int i = 0; i < samples; i++) output[i] = std::tanh(input[i]);
            }
            void configure(float sampleRate) {}
            void setGain(float gain) {}
            void setMix(float mix) {}
          };
        }}
        EOF
        
        cat > basics/include/signalsmith-basics/chorus.h << 'EOF'
        #pragma once
        #include <cmath>
        namespace signalsmith { namespace basics {
          class ChorusFloat {
          public:
            ChorusFloat() : phase(0.0f) {}
            void process(float* input, float* output, int samples) {
              for (int i = 0; i < samples; i++) {
                float lfo = std::sin(phase) * 0.1f;
                output[i] = input[i] * (1.0f + lfo);
                phase += 0.001f;
                if (phase > 6.28f) phase -= 6.28f;
              }
            }
            void configure(float sampleRate) {}
            void setRate(float rate) {}
            void setDepth(float depth) {}
            void setMix(float mix) {}
          private:
            float phase;
          };
        }}
        EOF
        
        cat > basics/include/signalsmith-basics/limiter.h << 'EOF'
        #pragma once
        #include <algorithm>
        namespace signalsmith { namespace basics {
          class LimiterFloat {
          public:
            LimiterFloat() {}
            void process(float* input, float* output, int samples) {
              for (int i = 0; i < samples; i++) output[i] = std::max(-1.0f, std::min(1.0f, input[i]));
            }
            void configure(float sampleRate) {}
            void setThreshold(float threshold) {}
            void setRelease(float release) {}
          };
        }}
        EOF
        
    - name: Install JUCE
      run: |
        git clone --depth 1 --branch 8.0.8 https://github.com/juce-framework/JUCE.git || git clone --depth 1 --branch 7.0.12 https://github.com/juce-framework/JUCE.git
    
    - name: Configure CMake
      run: |
        cmake -B build -DCMAKE_BUILD_TYPE=Release \
          -DJUCE_BUILD_EXTRAS=OFF -DJUCE_BUILD_EXAMPLES=OFF
    
    - name: Build
      run: |
        cmake --build build --config Release --target SimpleSynth_Standalone
    
    - name: Install AppImageTool
      run: |
        wget https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage
        chmod +x appimagetool-x86_64.AppImage
        sudo mv appimagetool-x86_64.AppImage /usr/local/bin/appimagetool
    
    - name: Create AppImage
      run: |
        mkdir -p SimpleSynth.AppDir/usr/bin
        mkdir -p SimpleSynth.AppDir/usr/share/applications
        mkdir -p SimpleSynth.AppDir/usr/share/icons/hicolor/256x256/apps
        
        # Find and copy the standalone executable
        find build -name "*SimpleSynth*" -type f -executable | head -1 | xargs -I {} cp {} SimpleSynth.AppDir/usr/bin/SimpleSynth
        
        # Create .desktop file
        cat > SimpleSynth.AppDir/SimpleSynth.desktop << EOF
        [Desktop Entry]
        Type=Application
        Name=SimpleSynth
        Comment=JUCE Audio Synthesizer
        Exec=SimpleSynth
        Icon=SimpleSynth
        Categories=AudioVideo;Audio;
        EOF
        
        # Create a simple icon (create a basic PNG)
        python3 -c "
        from PIL import Image, ImageDraw
        import sys
        try:
            img = Image.new('RGB', (256, 256), color='blue')
            draw = ImageDraw.Draw(img)
            draw.text((64, 128), 'SS', fill='white')
            img.save('SimpleSynth.AppDir/SimpleSynth.png')
            img.save('SimpleSynth.AppDir/usr/share/icons/hicolor/256x256/apps/SimpleSynth.png')
        except ImportError:
            # Fallback: create empty files
            open('SimpleSynth.AppDir/SimpleSynth.png', 'a').close()
            open('SimpleSynth.AppDir/usr/share/icons/hicolor/256x256/apps/SimpleSynth.png', 'a').close()
        " 2>/dev/null || {
            # Final fallback
            touch SimpleSynth.AppDir/SimpleSynth.png
            touch SimpleSynth.AppDir/usr/share/icons/hicolor/256x256/apps/SimpleSynth.png
        }
        
        # Copy desktop file to root
        cp SimpleSynth.AppDir/SimpleSynth.desktop SimpleSynth.AppDir/
        
        # Make AppRun executable
        cat > SimpleSynth.AppDir/AppRun << 'EOF'
        #!/bin/bash
        HERE="$(dirname "$(readlink -f "${0}")")"
        exec "${HERE}/usr/bin/SimpleSynth" "$@"
        EOF
        chmod +x SimpleSynth.AppDir/AppRun
        
        # Create AppImage
        appimagetool SimpleSynth.AppDir SimpleSynth.AppImage
    
    - name: Upload Linux Artifact
      uses: actions/upload-artifact@v4
      with:
        name: SimpleSynth-Linux
        path: SimpleSynth.AppImage

  build-macos:
    runs-on: macos-latest
    
    steps:
    - uses: actions/checkout@v4
      with:
        submodules: recursive
    
    - name: Install dependencies
      run: |
        brew install cmake pkg-config
    
    - name: Create signalsmith-basics stubs
      run: |
        mkdir -p basics/include/signalsmith-basics
        mkdir -p basics/include/stfx
        
        cat > basics/include/signalsmith-basics/reverb.h << 'EOF'
        #pragma once
        #include <cmath>
        namespace signalsmith { namespace basics {
          class ReverbFloat {
          public:
            float wet = 0.0f; float dry = 1.0f; float roomMs = 100.0f;
            float lowCutHz = 20.0f; float highCutHz = 20000.0f; float rt20 = 2.0f;
            ReverbFloat() {}
            void process(float** channels, int numSamples) {
              for (int i = 0; i < numSamples; i++) {
                for (int ch = 0; ch < 2; ch++) {
                  channels[ch][i] = channels[ch][i] * (dry + wet * 0.8f);
                }
              }
            }
            void configure(float sampleRate, float roomSize = 0.5f, float damping = 0.5f) {}
            void setRoomSize(float size) {} void setDamping(float damping) {} void setMix(float mix) {}
          };
        }}
        EOF
        
        cat > basics/include/signalsmith-basics/crunch.h << 'EOF'
        #pragma once
        #include <cmath>
        namespace signalsmith { namespace basics {
          class CrunchFloat {
          public:
            float fuzz = 0.0f; float drive = 1.0f; float toneHz = 5000.0f;
            float cutHz = 20000.0f; float outGain = 1.0f;
            CrunchFloat() {}
            void process(float** channels, int numSamples) {
              for (int i = 0; i < numSamples; i++) {
                for (int ch = 0; ch < 2; ch++) {
                  float sample = channels[ch][i] * drive;
                  channels[ch][i] = std::tanh(sample) * outGain * (1.0f + fuzz);
                }
              }
            }
            void configure(float sampleRate, int samplesPerBlock = 512) {}
            void setGain(float gain) { outGain = gain; } void setMix(float mix) {}
          };
        }}
        EOF
        
        cat > basics/include/signalsmith-basics/chorus.h << 'EOF'
        #pragma once
        #include <cmath>
        namespace signalsmith { namespace basics {
          class ChorusFloat {
          public:
            float mix = 0.0f; float depthMs = 5.0f; float detune = 0.0f; float stereo = 0.0f;
            ChorusFloat() : phase(0.0f) {}
            void process(float** channels, int numSamples) {
              for (int i = 0; i < numSamples; i++) {
                float lfo = std::sin(phase) * depthMs * 0.01f;
                for (int ch = 0; ch < 2; ch++) {
                  channels[ch][i] = channels[ch][i] * (1.0f + lfo * mix);
                }
                phase += 0.001f;
                if (phase > 6.28f) phase -= 6.28f;
              }
            }
            void configure(float sampleRate, int samplesPerBlock = 512) {}
            void setRate(float rate) {} void setDepth(float depth) { depthMs = depth; }
            void setMix(float mixVal) { mix = mixVal; }
          private:
            float phase;
          };
        }}
        EOF
        
        cat > basics/include/signalsmith-basics/limiter.h << 'EOF'
        #pragma once
        #include <algorithm>
        namespace signalsmith { namespace basics {
          class LimiterFloat {
          public:
            float inputGain = 1.0f; float outputLimit = 1.0f; float attackMs = 1.0f;
            float holdMs = 0.0f; float releaseMs = 10.0f;
            LimiterFloat() {}
            void process(float** channels, int numSamples) {
              for (int i = 0; i < numSamples; i++) {
                for (int ch = 0; ch < 2; ch++) {
                  float sample = channels[ch][i] * inputGain;
                  channels[ch][i] = std::max(-outputLimit, std::min(outputLimit, sample));
                }
              }
            }
            void configure(float sampleRate, int samplesPerBlock = 512) {}
            void setThreshold(float threshold) { outputLimit = threshold; }
            void setRelease(float release) { releaseMs = release; }
          };
        }}
        EOF
        
        cat > basics/include/stfx/units.h << 'EOF'
        #pragma once
        #include <cmath>
        namespace stfx { namespace units {
          inline float dbToGain(float db) { return std::pow(10.0f, db / 20.0f); }
        }}
        EOF
        
    - name: Install JUCE
      run: |
        git clone --depth 1 --branch 8.0.8 https://github.com/juce-framework/JUCE.git || git clone --depth 1 --branch 7.0.12 https://github.com/juce-framework/JUCE.git
    
    - name: Configure CMake
      run: |
        cmake -B build -DCMAKE_BUILD_TYPE=Release \
          -DJUCE_BUILD_EXTRAS=OFF -DJUCE_BUILD_EXAMPLES=OFF \
          -DCMAKE_OSX_ARCHITECTURES="x86_64;arm64"
    
    - name: Build
      run: |
        cmake --build build --config Release --target SimpleSynth_Standalone
    
    - name: Create DMG
      run: |
        # Find the .app bundle
        APP_PATH=$(find build -name "*.app" -type d | head -1)
        if [ -z "$APP_PATH" ]; then
          echo "Error: .app bundle not found"
          exit 1
        fi
        
        # Create DMG
        mkdir dmg_staging
        cp -R "$APP_PATH" dmg_staging/
        hdiutil create -volname "SimpleSynth" -srcfolder dmg_staging -ov -format UDZO SimpleSynth.dmg
    
    - name: Upload macOS Artifact
      uses: actions/upload-artifact@v4
      with:
        name: SimpleSynth-macOS
        path: SimpleSynth.dmg

  update-downloads:
    needs: [build-windows, build-linux, build-macos]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
    - uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts
    
    - name: Update download folder
      run: |
        # Clear existing downloads
        rm -f download/*
        
        # Copy new builds
        cp artifacts/SimpleSynth-Windows/SimpleSynth.exe download/
        cp artifacts/SimpleSynth-Linux/SimpleSynth.AppImage download/
        cp artifacts/SimpleSynth-macOS/SimpleSynth.dmg download/
        
        # List what we have
        ls -la download/
    
    - name: Commit and push updated downloads
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add download/
        git commit -m "Update standalone builds for all platforms" || exit 0
        git push